{
  "name": "yakuza",
  "version": "1.0.0",
  "description": "[![Build Status](https://travis-ci.org/Narzerus/yakuza.svg?branch=development)](https://travis-ci.org/Narzerus/yakuza)",
  "main": "yakuza.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/Narzerus/yakuza.git"
  },
  "scripts": {
    "coverage": "istanbul cover _mocha -- spec",
    "docs": "jsdoc . -c ./jsdocconfig.json",
    "test": "mocha spec"
  },
  "keywords": [
    "scraping",
    "framework"
  ],
  "author": {
    "name": "Rafael Vidaurre"
  },
  "license": "MIT",
  "dependencies": {
    "eventemitter2": "^0.4.14",
    "lodash": "^2.4.1",
    "needle": "^0.9.0",
    "q": "^1.1.1",
    "shortid": "^2.1.3"
  },
  "devDependencies": {
    "chai": "^2.1.0",
    "chai-as-promised": "^4.3.0",
    "jsdoc": "^3.3.0-beta2",
    "mocha": "^2.2.4",
    "nock": "^1.0.0",
    "should": "^5.0.1",
    "sinon": "^1.12.2",
    "sinon-chai": "^2.7.0"
  },
  "readme": "[![Build Status](https://travis-ci.org/Narzerus/yakuza.svg?branch=development)](https://travis-ci.org/Narzerus/yakuza)\n\nYakuza\n======\nYakuza is a heavy-weight, highly-scalable framework for scraping projects.\nWhether you are building small or massive scrapers, yakuza will keep your code clean, ordered and under control.\n\nInstallation\n------------\n`npm install yakuza`\n\nLooking for the docs?\n---------------------\n[Documentation](http://narzerus.github.io/yakuza)\n\nScraper structure\n=================\nYakuza introduces several concepts to help you build your scraper's structure\n\nTasks\n-----\nA task is the smallest unit in any scraper. It determines one specific goal for the scraper to\nachieve, such as **logging in** or **retrieving a list of articles**. Some task name examples:\n*getArticleList*, *getUserProfile*, *login*, *getLinks*.\n\nTasks can run one after the other or in parallel. Tasks can even be instanced multiple times for\na single job to be performed. For example, if we want to create a scraper that comments random\nstuff in a blog which needs a logged in user to comment, then *login* should always run before a\n*createComment* task. Maybe we want to create multiple comments for different blog posts at\nthe same time. Yakuza allows us to do something like this:\n\n1. Login\n2. Get list of blog posts\n3. Comment random gibberish in all blog posts found in parallel\n\nThe criteria which defines how a task is run and how many times it is instanced has to do with\nsomething called `builders`. We will get into that later in this document.\n\n\nAgents\n------\nAll tasks belong to an agent and it is the agent itself that determines the order in which tasks run and how they run. An agent usually represents a website, so in the case where we were scraping multiple blogs, the agent names could be *techCrunch* or *hackerNews*.\n\nAll agents usually have the same tasks with different implementations per agent. For example, both *techCrunch* and *hackerNews* will have a *getArticleList* task.\n\nAgents have a `plan` which determines which tasks will run in parallel and which will run sequentially. This is defined per agent as in some cases the synchrony required between tasks may vary depending on the website being scraped.\n\n\nScrapers\n--------\nScrapers hold `agents` together. In most projects you will have one scraper, since a scraper represents all the websites you will scrape and how you will scrape them (via its `agents` and their `tasks`).\n\nFollowing the previous example, we would create a scraper called *articles* whose purpose is to scrape articles from different blog sites.\n\nStructure summary\n-----------------\nSumming up, the structure in which Yakuza works is as follows:\n\n- Scraper1\n  - Agent1\n    - Task1\n    - Task2\n  - Agent2\n    - Task1\n    - Task2\n- Scraper2\n  - Agent3\n    - Task3\n\n\nAPI\n===\nLet's get our hands dirty by looking at Yakuza's API\n\nYakuza\n------\nTo use Yakuza we must first require it in our code:\n\n```javascript\nvar Yakuza = require('yakuza');\n```\n\nIt is important to point out that Yakuza is a **singleton** and therefore all `requires` of Yakuza will point to the **same instance**. The idea behind this is to allow the developer to define his file structure freely, whether it is one file for the whole project or multiple files for each task, agent and scraper used.\n\nScrapers\n--------\nThe first step is to create a scraper, as all other pieces of our structure should be associated to one.\n\n```javascript\nYakuza.scraper('articles');\n```\n\nAgents\n------\nWe can now start creating our agents\n\n```javascript\nYakuza.agent('articles', 'techCrunch');\n```\n\nRemember the `plan` property we mentioned before? Now is a good time to use that. The `plan` property is an array of task names. Each task in the array runs after the previous one. If an array is placed inside the `plan` array, all tasks inside it will run in parallel.\n\nThis plan runs `login`and `getArticlesList` sequentially:\n\n```javascript\nYakuza.agent('articles', 'techCrunch').setup(function (config) {\n  config.plan = [\n    'login',\n    'getArticlesList'\n  ];\n});\n```\n\nThis one runs `login` before the other tasks, but runs `getArticlesList` and `getUsersList` in parallel as they are in the same sub-array:\n\n```javascript\nYakuza.agent('articles', 'techCrunch').setup(function (config) {\n  config.plan = [\n    'login',\n    ['getArticlesList', 'getUsersList']\n  ];\n});\n```\n\nAgents can also define something called `routines` which in turn define a set of tasks to be run. For example you could want to define three routines:\n**onlyArticlesList**, **onlyUsersList**, **usersListAndArticlesList**\n\nThey would be defined like this:\n\n```javascript\nYakuza.agent('articles', 'techCrunch').routine('onlyArticlesList', ['login', 'getArticlesList']);\nYakuza.agent('articles', 'techCrunch').routine('onlyUsersList', ['login', 'getUsersList']);\nYakuza.agent('articles', 'techCrunch').routine('usersListAndArticlesList', ['login', 'getUsersList', 'getArticlesList']);\n```\n\nDont worry, routines will make more sense after we understand how to run a scraper\n\n\nTasks\n-----\nTasks are where you are going to spend most of your time. They hold the scraping logic and basically do all the dirty work.\n\n```javascript\n// Creating a task\nYakuza.task('articles', 'techCrunch', 'getArticlesList');\n```\n\nTasks have two important concepts: the `main` method, and the `builder`. First, let's start with the builder. As we mentioned previously, the builder is a method which defines how a `task` will be instanced. Tasks come with a default builder which simply instances them once.\n\nThe task being built will be instanced depending on what the builder method returns:\n- If it returns an array, it will instance the Task as many times as there are elements present inside the array.\n- If it returns anything other than an array, it will instance the Task once.\n** Note that if an empty array is returned, the task will be skipped **\n\nAlso, what is returned by the builder will be provided to the Task instances.\n\nA builder method is defined as follows (mind the name \"job\" in the method's parameter, as jobs will be explained right after this section):\n\n```javascript\n// Job is an accessor to some properties provided by the current job running\nYakuza.task('articles', 'techCrunch', 'getArticlesList').builder(function (job) {\n  return [1, 2, 3]; // Instances the task three times, one with each number as parameter\n  return []; // Skips the task completely\n  return [{a: 1}, {a: 2}]; // Instances the task twice with each object as parameter\n  return true; // Instances the task once (this is the default)\n});\n```\n\nThe second and most important concept is the `main` method, which defines the scraping logic itself.\nThe main method receives the following arguments:\n\n**task** has the following methods:\n- `success(data)`: marks the task as successful and emits a success event with the data passed to it\n- `fail(error, errorMessage)`: marks the task as failed, stops the current job and emits a fail event with the error object and error message passed\n- `share(key, value, [options])`: shares a value to tasks in the next execution block\n\n**params** passes whatever value was returned by the builder to instance this task\nFor example, if the builder returned `[1, 2, 3]` then three tasks would be instanced with params being the values `1`, `2` and `3` (one for each)\n\n**http** wrapper over [needle](https://github.com/tomas/needle) which is used for http requests. Other tools can be used instead of http, though it is recommended since it will log your requests, improve emitted errors and provide you with some utilities that might be useful.\nIt has the following utility methods:\n`getLog()`: provides a log of the current requests made by the task instance\n`get`, `post`, `put`, `patch`, `head`: generate http requests with the corresponding http verb, arguments are\npattern matched and can be:\n- an options object: It can have the same properties as [needle](https://github.com/tomas/needle) but also accepts:\n  - url: 'url to which the request should be made'\n  - data: 'data to be sent to the url (will be stringified in querystring format if passed to `get` and will be used as form data if passed to `post`\n- an url string: If an url is provided then no options should be passed.\n- callback: Callback method to be called when the request is finished, parameters received are:\n  - err: error object, `null` if no error is present\n  - res: response object, contains all response and request details provided by [needle](https://github.com/tomas/needle)\n  - body: body of the response as supported by [needle](https://github.com/tomas/needle)\nThe `http` object's request methods return a promise implemented with [Q](https://github.com/kriskowal/q)\nEach task **must** at some point call either `task.success` or `task.fail` for the scraper to work correctly. If both are called by the same task instance, an error will be raised\n\nSome examples:\n```javascript\nvar cheerio = require('cheerio');\n\nYakuza.task('articles', 'techCrunch', 'getArticlesList').main(function (task, http, params) {\n  http.get('www.foo.com', function (err, res, body) {\n    var $, articleLinks;\n\n    if (err) {\n      task.fail(err, 'Request returned an error');\n      return; // we return so that the task stops running\n    }\n\n    $ = cheerio.load(body);\n\n    articleLinks = [];\n\n    $('a.article').each(function ($article) {\n      articleLinks.push($article.attr('href'));\n    });\n\n    task.success(articleLinks); // Successfully return all article links found\n  });\n});\n```\n\nUsing parameters\n```javascript\nYakuza.task('foo', 'loginExampleCom', 'login').main(function (task, http, params) {\n  var username, password, opts;\n\n  username = params.username;\n  password = params.password;\n  opts = {\n    url: 'http://www.loginexample.com',\n    data: {\n      username: username,\n      pass: password\n    }\n  };\n\n  http.post(opts, function (err, res, body) {\n    if (err) {\n      task.fail(err, 'Error in request');\n      return;\n    }\n\n    if (body === 'logged in') {\n      task.success('loggedIn');\n      return;\n    }\n\n    task.success('wrongPassword'); // Still not an error though, we correctly detected that the password was wrong\n  });\n});\n```\n\nJobs\n----\nJobs are not part of the scraper structure itself but rather a product of it. Jobs are a one-time use you are giving to your scraper, so each time you want to scrape, you create a job. Jobs can receive parameters which can later be passed all the way down to the tasks, thus customizing the task's behavior (explained in the extras section).\n\nCreating a job:\n```javascript\n  // At this point our scrapers/agents/tasks are completely defined\n\n  // Here we create a job that will use the agent 'techCrunch' from our 'articles' scraper\n  var job = Yakuza.job('articles', 'techCrunch');\n\n  // .. At this point the job still doesn't know what to do. We can do either\n  // this:\n  job.enqueue('login').enqueue('getArticlesList');\n  // or this\n  job.enqueueTaskArray(['login', 'getArticlesList']);\n  // or if we had defined a routine we could do\n  job.routine('onlyArticlesList');\n```\n\nAt this point the job is almost ready to run, just one thing is missing: `events`. We need some way to listen to what's happening inside our job so we can make use of the data retrieved and be able to react to errors.\n\nTo listen to events you must use the `job.on` method.\n\nList of events:\n\n`job:success`: When the job finished successfully\narguments:\n- `response`: For now this is undefined, this may in the future return statistics of the job or other useful data\n\n`job:finish`: When the job finished, whether by fail or success\n- `response`: Same as `job:success`\n\n`job:fail`: When the job failed\narguments:\n- `response.task`: Instance of the task that failed\n- `response.error`: Error returned via `task.fail()`, (to get the error stack trace, use `response.error.stack`)\n- `response.requestLog`: Array of all requests and responses that led to the failure\n\n`task:<taskName>:success`: When a task finishes successfuly\n- `response.task`: Instance of the task that succeeded\n- `response.data`: Data provided via the `task.success()` method\n\n`task:<taskName>:fail`: When a task finishes on fail\n- `response.task`: Instance of the task that failed\n- `response.error`: Error returned via `task.fail()`, (to get the error stack trace, use `response.error.stack`)\n- `response.requestLog`: Array of all requests and responses that led to the failure\n\nEvents support wildcards, meaning you can do things like: `task:*:fail` to listen to any task which fails or `job:*` to listen to all events concerning the job itself.\n\nAn example:\n```javascript\n  var job = Yakuza.job('someScraper', 'someAgent');\n\n  job.on('job:fail', function (response) {\n    // Handle job failure\n  });\n\n  job.on('task:*:fail', function (response) {\n    console.log(response.task.taskId + ' failed!');\n  });\n\n  job.on('task:*:success', function (response) {\n    // Handle all successful tasks\n  });\n\n  job.on('task:login:fail', function (response) {\n    console.log('Failed to log in');\n  });\n\n  // Enqueue tasks and run job\n```\n\nRunning a Job:\nTo run the job simply use the job.run() method, please keep in mind jobs are not reusable.\n\n```javascript\n  job.run(); // Job will start running\n```\n\nHooks\n=====\nHooks are run in specific moments of an instanced `task`'s life (before emitting events to the outside), and they can modify the scrapers default behavior. \nTo specify a `task`'s hooks use its `setup` method.\n\n```javascript\nYakuza.task('scraper', 'agent', 'someTask').setup(function (config) {\n  config.hooks = {\n    'onFail': function (task) {\n      // ... do stuff\n    },\n    'onSuccess': function (task) {\n      // ... do stuff\n    }\n  };\n});\n```\n\nonFail\n------\nRuns when a task fails, `onFail` can be used to do some fancy stuff like retrying failed tasks right away.\n\nThe `task` object passed to the `onFail` hook has the following properties:\n- runs: Amount of times the task has run (starts from 1)\n- params: Parameters with which the task was instanced for the first time (doesn't change)\n- rerun([params]): Re-runs the task with original parameters (passed by the builder), if an object is provided, it will replace the task's parameters with the object passed.\n- error: Error thrown by the task's `fail` event, (if passed)\n\nonSuccess\n---------\nRuns when a task succeeds, `onSuccess` can be used to stop the job's execution even though the task was successful. This can be useful when we need to stop our execution depending on the data we receive.\n\nThe `task` object passed to the `onSuccess` hook has the following properties:\n- data: Data returned by the `task`'s success() method\n- stopJob(): Method which, if called, stops the job execution in once the current `executionBlock` is done\n\nHere's an example on when this could be useful:\n\n```javascript\n  Yakuza.task('scraper', 'agent', 'login').setup(function (config) {\n    config.hooks = {\n      'onSuccess': function (task) {\n        // We stop the job if the loginStatus returns `wrongPassword`\n        // remember: in many cases wrongPassword might NOT be an error, identifying what's the login status\n        // can be part of a successful scraping process as well.\n      \n        if (task.data.loginStatus === 'wrongPassword') {\n          task.stopJob();\n        }\n      }\n    };\n  }).main(function (task, http, params) {\n    var opts;\n    \n    opts = {\n      url: 'http://someurl.com',\n      data: {\n        username: 'foo',\n        password: 'bar'\n      }\n    };\n    \n    http.post(opts)\n    .then(function (res, body) {\n      if (body === 'wrong password') {\n        task.success({loginStatus: 'wrongPassword});\n      } else {\n        task.success({loginStatus: 'authorized});\n      }\n    })\n    .fail(function (error) {\n      task.fail(error);\n    })\n    .done();\n  });\n```\n\nWhen calling `task.stopJob()` the `task:<taskName>:success` event is, of course, still fired.\n\nAdvanced\n========\nIf you reached this section, then you should already be able to use Yakuza's basic features and create a working scraper.\nThe following are other important features Yakuza provides which will help you with more complex stuff in your scrapers.\n\nJob parameters\n--------------\nJob parameters are specific information you want to pass to certain tasks in your code to customize their behaviour or allow them to work in a more generic fashion.\n\nPassing parameters to a job:\n```javascript\n  var job = Yakuza.job('someScraper', 'someAgent', {search: 'peanuts'});\n```\n\nJob parameters can now be passed to tasks via the builder method in the following way:\n```javascript\nYakuza.task('someScraper', 'someAgent', 'searchTheNews')\n  .builder(function (job) {\n    return job.params.search; // Instances the task ONCE with params = 'peanuts'\n  })\n  .main(function (task, http, params) {\n    var opts = {\n      url: 'http://www.some-search-site.com',\n      data: {\n        search: params\n      }\n    };\n\n    // The following request will be: GET http://www.some-search-site.com?search=peanuts\n    http.get(opts, function (err, res, body) {\n      // Do stuff ..\n      task.success(result);\n    });\n  });\n```\n\nSharing between tasks\n---------------------\nVery frequently you need a certain task to access something from a previous task.\nExposing values from a task:\n```javascript\nYakuza.task('articlesScraper', 'fooBlog', 'getArticleUrls', function (task, http, params) {\n  // ... Get list of articles from fooBlog here\n  task.share('articleUrlList', articleUrls); // Exposes retrieved list of article urls to the other tasks\n  // ... Do other stuff\n});\n```\nAt this point, all tasks from the next **execution blocks** will have access to the values shared. Tasks from the same **execution block** will not be able to access the variables since they run in parallel and it is uncertain if the value has been shared or not. So, if you need a value shared by a certain task, put that task in an earlier **execution block**.\n\nYou can access shared variables in your tasks' builders like this:\n```javascript\nYakuza.task('articlesScraper', 'fooBlog', 'getArticleData')\n  .builder(function (job) {\n    var urls = job.shared('getArticleUrls.articleUrlList'); // <task that shared the value>.<key of the value>\n\n    return urls; // Will instance the `getArticleData` task once for each url retrieved\n  })\n  .main(function (task, http, params) { // Here params = some article url\n    // ... Scrape article urls to get article data\n    task.success(data); // emit data to the outside\n  });\n```\n\nin the previous example we are instancing the `getArticleData` task once per url we got, and all of these are run in parallel. The only problem with this is that we will recieve one `task:getArticleData:success` event per instance, meaning we would have to join all the results in an array as we would get them separately.\n\nThis might not be ideal depending on our use case, so we should create another task returns all our results from our `getArticleData` instances in one array\n\nFirst, we have a little problem... What happens when we share a value on a key which is already used by another instance of the same task? Well, by default the value gets overwritten.\nSay a task shares some value to the key `foo`, and there are two instances, then we wouldn't know which is the final value because it depends on which task finished last:\n```javascript\n  // instance1: value equals 1\n  // instance2: value equals 2\n  task.share('foo', value);\n```\n\nTo fix this we need to change the way in which values are being shared. This can be done by adding an `options` object to the `share()` method.\n\nCurrent properties accepted in the `share` method:\n\n**method**: Can be a string or a function. If a string then Yakuza will search for the sharing methods it knows about, if a function is given Yakuza will use it as the sharing method.\npre-built sharing methods *(More pre-built methods pending)*:\n  - `replace` (default): Replaces previous value with new value\n\nTo define reusable custom sharing methods, you can use the scraper's `addShareMethod` which receives:\n- `methodName`: Name of your sharing method (the one you use in the `method` property in your `options` object)\n- `shareFunction`: A function that returns the new value of the shared value. Arguments for it are:\n  - `currentValue`: Current value saved, (undefined if nothing has been shared yet)\n  - `newValue`: New value to be shared\n\nAn example of a custom sharing method which would allow us to join all urls in an array:\n```javascript\nYakuza.scraper('articlesScraper')\n  .addShareMethod('joinInArray', function (currentValue, newValue) {\n    var current = currentValue;\n    if (current === undefined) {\n      current = [];\n    }\n\n    current.push(newValue);\n    return current; // Shared value will always be an array\n  });\n```\n\nNow we should share our results with our new sharing logic\n```javascript\nYakuza.task('articlesScraper', 'fooBlog', 'getArticleData').main(function (task, http, params) {\n  // Do stuff and get article data\n  task.share('allArticles', articleData, {method: 'joinInArray'});\n  // ...\n});\n```\nPerfect, our articles are now all in one single shared value. We should now retrieve it with a tiny final task. Let's call it `getJoinedArticles`\n\n```javascript\nYakuza.task('articlesScraper', 'fooBlog', 'getArticleData')\n  .builder(function (job) {\n    return job.shared('getArticleData.allArticles'); // Retrieve array of articles\n  })\n  .main(function (task, http, params) {\n    task.success(params); // Simply expose the data to the outside\n  });\n```\n\nRunning task instances sequentially\n----------------------------------\nSometimes because of server limitations, we might want several instances of the same task to run sequentially. Take our previous example about articles, where we instanced `getArticleData` multiple times. Let's say the server doesn't allow us to view multiple articles in parallel because god knows why. We would need to change the default behavior of task instances and run them one after the other.\n\nThis can be achieved in the agent plan by changing the `selfSync` property:\n```javascript\nYakuza.agent('articles', 'fooBlog').setup(function (config) {\n  config.plan = [\n    'getArticlesList',\n    {taskId: 'getArticleData', selfSync: true}\n  ];\n});\n```\n\nSaving cookies\n--------------\nA lot of times we need to preserve cookies so that they exist for other tasks. This can be achieved by a method called `saveCookies()`.\n\nExample:\n```javascript\nYakuza.task('scraper', 'agent', 'login').main(function (task, http, params) {\n  // .. Send a login form\n  task.saveCookies();\n  // .. Do more stuff\n  task.success('authorized');\n});\n```\n\nAny new task will now have its `http` object initialized with the cookies that were present at the time `saveCookies` was called. Notice that only tasks from the next **execution block** will be afected.\n\nRetrying tasks\n--------------\nIn many cases the websites we scrape are sloppy, implemented in very wrong ways or simply unstable. This will cause our tasks to sometimes fail without warning. For this reason `Yakuza` provides a way of re-running tasks when this happens via it's `onFail` hook.\n\nWhen a task is rerun, it restarts to the point in which it was instanced. Except (for some properties like `startTime` which marks the moment when the task was first run)\n\n```javascript\nYakuza.task('scraper', 'agent', 'login').setup(function (config) {\n  config.hooks = {\n    onFail: function (task) {\n      if (task.runs <== 5) {\n        // Will retry the task a maximum amount of 5 times\n        task.rerun();\n      }\n    }\n  };\n});\n```\n\nYou can find the `task` object's properties on the **Hooks section**\n\nGlossary\n========\n\nExecution Block\n---------------\nAn execution block is a set of tasks that run in parallel. For example, take the following plan:\n```javascript\nYakuza.agent('scraper', 'agent').setup(function (config) {\n  config.plan = [\n    'task1', // Execution block 1\n    ['task2', 'task3'], // Execution block 2\n    'task4' // Execution block 3\n  ];\n});\n```\n\nExecution blocks run sequentially, meaning one execution block will only run when the previous block was run or **skipped**.\n\\* Tasks are skipped if not `enqueued` or if their builders return empty arrays. Execution blocks are skipped if all tasks inside it are skipped as well.\n\n\nContribution\n============\nAt this time, Yakuza is in its early days. For this reason all contributions and issues are more than welcome, they are needed. Yakuza is a very ambitious project that requires a lot of real-life usage to understand how it can be improved.\n\nBecause of the size of this project, maintainability is an important concern. For that reason these guidelines **must** be followed for a pull request to be merged:\n\nBranch structure\n----------------\nEach pull request will come in its own branch and with a specific naming convention.\n\nExisting branches:\n`master`: Only for production-ready releases, commits in this code **are** part of a release\n`development`: This is the branch you will target your pull requests to. It contains the latest changes that will probably be part of a new release but are not yet available to the public.\n\nBranch naming convention:\n`hotfix/<branch name>`: For hotfix pull-requests, basically any quick fixes\n`style/<branch name>`: For fixes in code styling, (make linters pass)\n`feature/<branch name>`: For feature pull-requests, these are bigger and should **only** contain changes regarding the feature implemented\n`bug/<branch name>`: For bug fixes\n`refactor/<branch name>`: For repo improvements and refactoring in general\n\nRequisites for a PR to be accepted\n----------------------------------\n- If it is a feature, it should follow what we think will help Yakuza go forward, this means truly useful features that will help more people, and not something that only helps your use case.\n** We recommend creating a discussion about your idea before actually coding**\n- All tests must pass. Add tests to whatever you add to the framework (See testing guidelines below).\n- Merge conflicts should be fixed on your end.\n- Please note that your PR may be on discussion for a while, but don't worry: if it is heading the right way it will make it to the master branch.\n\nJSDocs\n------\nJSDocs should be added for any new methods/classes you add to Yakuza.\n\nTesting\n-------\nTo test Yakuza run the following command:\n`npm test` and make use all tests pass.\n\nWe use [Mocha](http://mochajs.org/) as our test runner and [Chai](http://chaijs.com/) as our assertion library.\n\nWe use ESLint as our linter.\n\nKnown Issues\n------------\n- Cookies with some special characters (like `:`) are not correctly parsed. This has to do with a bug in the [needle](https://github.com/tomas/needle) package and a PR with the fix is currently waiting to be merged\n",
  "readmeFilename": "Readme.md",
  "gitHead": "1585f6e6dac592c1a0e0b51fec5a3c38ee1df04d",
  "bugs": {
    "url": "https://github.com/Narzerus/yakuza/issues"
  },
  "homepage": "https://github.com/Narzerus/yakuza",
  "_id": "yakuza@1.0.0",
  "_shasum": "fdfa6c2377355058e2e934990870e29cbfd9e3a4",
  "_from": "../yakuza"
}
